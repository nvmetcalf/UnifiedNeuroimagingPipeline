function [PSA region_order] = compute_surface_power_spectrum(FunctionalSurfaceTimeSeries, LeftHemiSphereRegionsGifti, RightHemiSphereRegionsGifti, Format, LeftHemiSphereAuxMask, RightHemiSphereAuxMask, VertexCountThreshold, NumberOfRuns, NormalizeByVariance, LeftSurfaceShape, RightSurfaceShape)
%   LeftSurfaceShape =  Shape file to use for the left hemisphere. Usually
%   in the atlas/fsaverage_10k folder of the subject you are generating the
%   seed correlations for.
%       <SubjectID>.L.atlasroi.10k_fs_LR.shape.gii
%   RightSurfaceShape = Shape file to use for the right hemisphere. Should
%   be in the same location as the LeftSurfaceShape. 
%       <SubjectID>.R.atlasroi.10k_fs_LR.shape.gii
%   FunctionalSurfaceTimeSeries = dtseries that contains the surface BOLD
%       timeseries. Should end in dtseries.nii
%   LeftHemiSphereRegionsGifti  = Gifti that contains a all left hemisphere
%       regions. Usually generated by region2gii.
%   RightHemiSphereRegionsGifti = Gifti that contains a all right hemisphere
%       regions. Usually generated by region2gii.
%   Format = Expanded format generated by DVAR/DDAT that denotes frames
%       that should and should not be included in the calculation of seed
%       correlations.
%   LeftHemiSphereAuxMask = Mask to apply to left hemishpere regions.
%       Verticies defined in the mask are ignored in the calculation of seed
%       correlations.
%   RightHemiSphereAuxMask = Mask to apply to right hemishpere regions.
%       Verticies defined in the mask are ignored in the calculation of seed
%       correlations.

    %detect where wb_command is located
    [Status wb_command_path] = system('which wb_command','-echo');
    assert(~Status);
    
    if(~exist('Format'))
        error('A Format was not specified for frames to include in the correlation.');
        return;
    end
        
    if(wb_command_path(length(wb_command_path)) ~= 'd')
        %strip off the last character. It is a hidden character of some
        %type that doesn't need to be there
        wb_command_path = wb_command_path(1:length(wb_command_path)-1);
    end
    
    if(~exist('VertexCountThreshold'))
        VertexCountThreshold = -1
    end
    
    if(exist(Format,'file'))
        disp(['Reading format from ' Format]);
        [result ReadFormat] = system(['cat ' Format],'-echo');
        
        [result Format] = system(['format2lst -e "' ReadFormat '"'], '-echo');
    end

    if(~exist('NormalizeByVariance'))
        NormalizeByVariance = false;
    end
    
    region_order = [];
    
    PSA = struct('PowerSpectrum',{},'FrequenceDistribution',{},'SeedVertexCount',{});
    PSA(1).PowerSpectrum = [];
    PSA(1).FrequenceDistribution = [];
    PSA(1).SeedVertexCount = [];
    
    %read in the surface template shapes files
    if(~exist('LeftSurfaceShape') || isempty('LeftSurfaceShape'))
        LeftSurfaceShape = '/data/nil-bluearc/corbetta/PP_SCRIPTS/SurfacePipeline/GiiTemplates/TEMPLATE.L.atlasroi.10k_fs_LR.shape.gii';
    end
    
	AtlasLeftHemiSphereShapeMask = LeftSurfaceShape;
	AtlasLeftHemiSphereVertexMask = gifti(AtlasLeftHemiSphereShapeMask);
	AtlasLeftHemiSphereVertexMask = cast(AtlasLeftHemiSphereVertexMask.cdata,'uint8');

    if(~exist('RightSurfaceShape') || isempty('RightSurfaceShape'))
        RightSurfaceShape = '/data/nil-bluearc/corbetta/PP_SCRIPTS/SurfacePipeline/GiiTemplates/TEMPLATE.R.atlasroi.10k_fs_LR.shape.gii';
    end
    
	AtlasRightHemiSphereShapeMask = RightSurfaceShape;
	AtlasRightHemiSphereVertexMask = gifti(AtlasRightHemiSphereShapeMask);
	AtlasRightHemiSphereVertexMask = cast(AtlasRightHemiSphereVertexMask.cdata,'uint8');

    AltasMask = cast([AtlasLeftHemiSphereVertexMask; AtlasRightHemiSphereVertexMask], 'uint8');
    
    %read in each hemisphere region gifti file and cast the values as uint16 to
    %save memory as each vertex will have a whole number. This will give us
    %2^16 possible region labels
    
    if(~isempty(LeftHemiSphereRegionsGifti))
        ROI_LeftHemiSphere = gifti(LeftHemiSphereRegionsGifti);

        try 
            ROI_LeftHemiSphere_Names = ROI_LeftHemiSphere.labels.name;
        catch
            ROI_LeftHemiSphere_Names = [];
        end
        
        ROI_LeftHemiSphere = cast(ROI_LeftHemiSphere.cdata,'uint16');
    else
        ROI_LeftHemiSphere = zeros(length(AtlasLeftHemiSphereVertexMask),1);
    end
    

    if(~isempty(RightHemiSphereRegionsGifti))
        ROI_RightHemiSphere = gifti(RightHemiSphereRegionsGifti);

        try 
            ROI_RightHemiSphere_Names = ROI_RightHemiSphere.labels.name;
        catch
            ROI_RightHemiSphere_Names = [];
        end
        
        ROI_RightHemiSphere = cast(ROI_RightHemiSphere.cdata,'uint16');
    else
        ROI_RightHemiSphere = zeros(length(AtlasRightHemiSphereVertexMask),1);
    end

    %Initialize the correlation matrix stack
    RegionList = unique([ROI_LeftHemiSphere; ROI_RightHemiSphere;]);
    RegionList(1) = [];    %strip off the undefined region
        
    % Load the Cifti surface BOLD timecourse  
    if(exist(FunctionalSurfaceTimeSeries))
    	cii = ciftiopen([FunctionalSurfaceTimeSeries], wb_command_path);
    else
        error([ 'Could not find ' FunctionalSurfaceTimeSeries]);
    end
    
    cii = cii.cdata';
           
    %make sure the format is for as many frames as we have in the
    %timecourse
    if(length(cii(:,1)) ~= length(Format))
        disp(['BOLD Frames in timecourse: ' num2str(length(cii(:,1))) ' Number of Frames encoded by format: ' num2str(length(Format))]);
        error('Format encodes for a different number of frames than are present in the BOLD timecourse.');
    end
    
	%% See if the format for this subject is binary or a string
	if(ischar(Format))
        %it is a string, so binarize it
        Binary_Format = uint8(zeros(size(Format)));
        Binary_Format(Format == '+') = 1;
    else
        %it is binary, so just extract it
        Binary_Format = Format;
    end
        
	fprintf('\nNumber of used frames = %d/%d\n',sum(Binary_Format),length(Binary_Format))
    
    AuxMask = ones(length([AtlasLeftHemiSphereVertexMask; AtlasRightHemiSphereVertexMask]),1);
    
    %put together the auxillary masks if one or both are specified
    % 2 = masked out of surface due to auxillary mask
    % 1 = not masked out due to auxillary mask
    if(exist('LeftHemiSphereAuxMask') || exist('RightHemiSphereAuxMask'))
        disp('Reading Auxillary Mask...');
                
        %see if there is a left hemisphere aux mask and mask by the
        %hemispehere mask
        if(~isempty(LeftHemiSphereAuxMask))
            
            disp(['Reading: ' LeftHemiSphereAuxMask]);
            OriginalLeftHemiSphereAuxMaskVertices = gifti(LeftHemiSphereAuxMask);
            
            %binarize the mask
            for i = 1:length(OriginalLeftHemiSphereAuxMaskVertices.cdata)
                if(OriginalLeftHemiSphereAuxMaskVertices.cdata(i) > 0)
                    OriginalLeftHemiSphereAuxMaskVertices.cdata(i) = 2;
                    LeftHemiSphereAuxMaskVertices_Compliment(i,1) = 0;
                else
                    OriginalLeftHemiSphereAuxMaskVertices.cdata(i) = 1;
                    LeftHemiSphereAuxMaskVertices_Compliment(i,1) = 1;
                end
            end
            
            LeftHemiSphereAuxMaskVertices = cast(OriginalLeftHemiSphereAuxMaskVertices.cdata,'uint8');
            AuxMask(1:length(LeftHemiSphereAuxMaskVertices)) = LeftHemiSphereAuxMaskVertices;   
            clear LeftHemiSphereAuxMaskVertices;
            
        end
        
        %see if there is a right hemisphere aux mask and mask by the
        %hemisphere mask
        if(~isempty(RightHemiSphereAuxMask))
            
            disp(['Reading: ' RightHemiSphereAuxMask]);
            OriginalRightHemiSphereAuxMaskVertices = gifti(RightHemiSphereAuxMask);
            
            %binarize the mask and make its compliment
            for i = 1:length(OriginalRightHemiSphereAuxMaskVertices.cdata)
                if(OriginalRightHemiSphereAuxMaskVertices.cdata(i) > 0)
                    OriginalRightHemiSphereAuxMaskVertices.cdata(i) = 2;
                    RightHemiSphereAuxMaskVertices_Compliment(i,1) = 0;
                else
                    OriginalRightHemiSphereAuxMaskVertices.cdata(i) = 1;
                    RightHemiSphereAuxMaskVertices_Compliment(i,1) = 1;
                end
            end
            
            RightHemiSphereAuxMaskVertices = cast(OriginalRightHemiSphereAuxMaskVertices.cdata,'uint8');
            AuxMask(length(AuxMask)-length(RightHemiSphereAuxMaskVertices)+1:length(AuxMask)) = RightHemiSphereAuxMaskVertices;  
            clear RightHemiSphereAuxMaskVertices;
            
            RightHemisphere_Masked_Verticies = AtlasRightHemiSphereVertexMask .* cast(RightHemiSphereAuxMaskVertices_Compliment,'uint8');
    
        end
    end
   
    %row = time
    %column = vertex
	TC = cii;
    clear cii;
    
    %need to 0/NaN out the bad frames
    for z = 1:length(Binary_Format)
        if(~Binary_Format(z))
            TC(z,:) = 0;
        end
    end
    
    % 2 = masked out of surface due to auxillary mask
    % 1 = not masked out due to auxillary mask
    % 0 = masked out due to surface atlas mask (left and right hemi's have
    %       different numbers of vertices)
    % at this point, all the masks are combined into a single vertex
    % vector.
    AuxMask = cast(AuxMask,'uint8') .* AltasMask;
    
    clear AtlasMask;
    
    if(exist('LeftHemiSphereAuxMaskVertices_Compliment'))
        LeftHemisphere_Masked_Verticies = AtlasLeftHemiSphereVertexMask .* cast(LeftHemiSphereAuxMaskVertices_Compliment,'uint8');
    else
        LeftHemisphere_Masked_Verticies = AtlasLeftHemiSphereVertexMask;
    end
    
    if(exist('RightHemiSphereAuxMaskVertices_Compliment'))
        RightHemisphere_Masked_Verticies = AtlasRightHemiSphereVertexMask .* cast(RightHemiSphereAuxMaskVertices_Compliment,'uint8');
    else
        RightHemisphere_Masked_Verticies = AtlasRightHemiSphereVertexMask;
    end
    
    clear AtlasLeftHemiSphereVertexMask AtlasRightHemiSphereVertexMask;
    
    %remove verticies that are not in the surface atlas mask
    AuxMaskFiltered = AuxMask(find(AuxMask > 0));
    
    %apply the Auxillary mask to the ROIs and time course
    % auxillary mask values are greater than 1 (eg. 2)
    TC(:,find(AuxMaskFiltered > 1)) = NaN;

    % Index the hemisphere ROIs into the common atlas
    CIFTI_ROI = vertcat(ROI_LeftHemiSphere, ROI_RightHemiSphere);
    CIFTI_ROI = CIFTI_ROI(find(AuxMask > 0), 1);
    
	
     
    if(length(TC(1,:)) ~= length(CIFTI_ROI))
        error('BOLD surface timecourse and region hemisphere vertex count are different after Auxillary masking.');
    end
     
    disp(['Creating Power Spectrum']);     
	% Make ROI Correlation Matrix
	ROITC = [];
    
    RunStart = 1;
    RunLength = length(TC(:,1))/NumberOfRuns;
    
    for k = 1:NumberOfRuns
        CurrentRunTimeSeries = TC(RunStart:RunStart+RunLength,:);
        region_order = [];
        
        %calculate the mean timecourse for each region
        for i = 1:length(RegionList)
            region_order = horzcat(region_order, RegionList(i));
            
            %grab the vertices for this region. Could be more efficient than
            %what his here
            Vertices = find(CIFTI_ROI == RegionList(i));

            TimeCourses = [];
            for j = 1:length(Vertices)
                TimeCourses = horzcat(TimeCourses, CurrentRunTimeSeries(:,Vertices(j)));
            end

            if(~isempty(TimeCourses))
                NumberOfVerticies = length(TimeCourses(1,:));
            else
                NumberOfVerticies = 0;
            end

            if(NumberOfVerticies < VertexCountThreshold)
                TimeCourses = nan(length(ROITC(:,1)),1);
                ROITC = horzcat(ROITC, TimeCourses);
            elseif(length(TimeCourses(1,:)) == 1)
                ROITC = horzcat(ROITC, TimeCourses);
                NumberOfVerticies = 1;
            else
                ROITC = horzcat(ROITC, nanmean(TimeCourses')');
                NumberOfVerticies = length(TimeCourses(1,:));
            end

            SlidingWindow = 32;
            AmountOfOverlap = SlidingWindow/2;
            NFFT = 2^(nextpow2(SlidingWindow)+1);
            fs = 1/2;

            %load verticies
            if(NormalizeByVariance)
                TC_Var = nanvar(ROITC(:,i));
                
                ROI_TC = ROITC(:,i) ./ TC_Var;
            else
                ROI_TC = ROITC(:,i);
            end
            
            [PSA(k).PowerSpectrum(:,i), PSA(k).FrequenceDistribution(:,i)] = pwelch(ROI_TC', SlidingWindow, AmountOfOverlap, NFFT, fs);

%             figure(1),clf
%             plot(PSA(k).FrequenceDistribution(:,i),PSA(k).PowerSpectrum(:,i)),set(gca,'yscale','log')

            PSA(k).SeedVertexCount = horzcat(PSA(k).SeedVertexCount, NumberOfVerticies);
        end
    end
end


function [PSA region_order] = compute_volume_power_spectrum(Conc, ROI_Filenames, Format, NormalizeByVariance)
%   LeftSurfaceShape =  Shape file to use for the left hemisphere. Usually
%   in the atlas/fsaverage_10k folder of the subject you are generating the
%   seed correlations for.
%       <SubjectID>.L.atlasroi.10k_fs_LR.shape.gii
%   RightSurfaceShape = Shape file to use for the right hemisphere. Should
%   be in the same location as the LeftSurfaceShape. 
%       <SubjectID>.R.atlasroi.10k_fs_LR.shape.gii
%   FunctionalSurfaceTimeSeries = dtseries that contains the surface BOLD
%       timeseries. Should end in dtseries.nii
%   LeftHemiSphereRegionsGifti  = Gifti that contains a all left hemisphere
%       regions. Usually generated by region2gii.
%   RightHemiSphereRegionsGifti = Gifti that contains a all right hemisphere
%       regions. Usually generated by region2gii.
%   Format = Expanded format generated by DVAR/DDAT that denotes frames
%       that should and should not be included in the calculation of seed
%       correlations.
%   LeftHemiSphereAuxMask = Mask to apply to left hemishpere regions.
%       Verticies defined in the mask are ignored in the calculation of seed
%       correlations.
%   RightHemiSphereAuxMask = Mask to apply to right hemishpere regions.
%       Verticies defined in the mask are ignored in the calculation of seed
%       correlations.

    if(~exist('Format'))
        error('A Format was not specified for frames to include in the correlation.');
        return;
    end
       
    if(exist(Format,'file'))
        disp(['Reading format from ' Format]);
        [result ReadFormat] = system(['cat ' Format],'-echo');
        
        [result Format] = system(['format2lst -e "' ReadFormat '"'], '-echo');
    end

    %% See if the format for this subject is binary or a string
	if(ischar(Format))
        %it is a string, so binarize it
        Binary_Format = uint8(zeros(size(Format)));
        Binary_Format(Format == '+') = 1;
    else
        %it is binary, so just extract it
        Binary_Format = Format;
    end
        
	fprintf('\nNumber of used frames = %d/%d\n',sum(Binary_Format),length(Binary_Format))
    
    if(~exist('NormalizeByVariance'))
        NormalizeByVariance = false;
    end
    
    
    PSA = struct('PowerSpectrum',{},'FrequenceDistribution',{},'SeedVertexCount',{});
    PSA(1).PowerSpectrum = [];
    PSA(1).FrequenceDistribution = [];
    PSA(1).SeedVertexCount = [];
    
    
    %load the conc file
    [fc_TC NumberOfRuns RunLengths] = load_4dfp_conc(Conc, 2);
    
    %load the ROIs and extract the ROI timeseries
    SeedTC = [];
    
    for i=1:length(ROI_Filenames)
        region_filename = ROI_Filenames{i};
        
        ROI = read_4dfp_img(region_filename);
                
        ROITC = mean(fc_TC.voxel_data(ROI.voxel_data > 0,:));
        SeedTC = horzcat(SeedTC, ROITC');
    end
           
    %make sure the format is for as many frames as we have in the
    %timecourse
    if(length(SeedTC(:,1)) ~= length(Format))
        disp(['BOLD Frames in timecourse: ' num2str(length(cii(:,1))) ' Number of Frames encoded by format: ' num2str(length(Format))]);
        error('Format encodes for a different number of frames than are present in the BOLD timecourse.');
    end
    

    disp(['Creating Power Spectrum']);     
	% Make ROI Correlation Matrix
	ROITC = [];
    
    RunStart = 1;
    
    for k = 1:NumberOfRuns
        CurrentRunTimeSeries = SeedTC(RunStart:RunStart+RunLengths(k)-1,:);
        region_order = [];
        
        %calculate the mean timecourse for each region
        for i = 1:length(ROI_Filenames)
            region_order = horzcat(region_order, ROI_Filenames(i));
            
            %grab the voxels for this region. Could be more efficient than
            %what his here
            ROI_TC = CurrentRunTimeSeries(:,i);

            SlidingWindow = 32;
            AmountOfOverlap = SlidingWindow/2;
            NFFT = 2^(nextpow2(SlidingWindow)+1);
            fs = 1/2;

            %load verticies
            if(NormalizeByVariance)
                TC_Var = nanvar(ROITC);
                
                ROI_TC = ROITC ./ TC_Var;
            end
            
            [PSA(k).PowerSpectrum(:,i), PSA(k).FrequenceDistribution(:,i)] = pwelch(ROI_TC, SlidingWindow, AmountOfOverlap, NFFT, fs);

%             figure(1),clf
%             plot(PSA(k).FrequenceDistribution(:,i),PSA(k).PowerSpectrum(:,i)),set(gca,'yscale','log')

        end
        RunStart = RunStart + RunLengths(k);
    end
end


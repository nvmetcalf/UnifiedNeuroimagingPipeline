function [SeedCorrMatrix Seed_TC_Var SeedVertexCount SeedVertexCountIgnored SeedVertexCountInitial ROITC ROI_UnfilteredTC Cifti_ROI Read_ROI] = SurfaceSeedCorrel(FunctionalSurfaceTimeSeries, LeftHemiSphereRegionsGifti, RightHemiSphereRegionsGifti, Format, LeftHemiSphereAuxMask, RightHemiSphereAuxMask, CalculateSurfaceMaps, VertexCountThreshold, MakePCONN, MinFrames, LeftSurfaceShape, RightSurfaceShape)
%function [SeedCorrMatrix Seed_TC_Var SeedVertexCount SeedVertexCountIgnored] = SurfaceSeedCorrel(FunctionalSurfaceTimeSeries, LeftHemiSphereRegionsGifti, RightHemiSphereRegionsGifti, Format, LeftHemiSphereAuxMask, RightHemiSphereAuxMask, CalculateSurfaceMaps, VertexCountThreshold, MakePCONN, MinFrames, LeftSurfaceShape, RightSurfaceShape)
%% [SeedCorrMatrix Seed_TC_Var SeedVertexCount] = SurfaceSeedCorrel(LeftSurfaceShape, RightSurfaceShape, FunctionalSurfaceTimeSeries, LeftHemiSphereRegionsGifti, RightHemiSphereRegionsGifti, Format, LeftHemiSphereAuxMask, RightHemiSphereAuxMask, CalculateSurfaceMaps, VertexCountThreshold, MakePCONN, MinFrames)
%   FunctionalSurfaceTimeSeries = dtseries that contains the surface BOLD
%       timeseries. Should end in dtseries.nii
%   LeftHemiSphereRegionsGifti  = Gifti that contains a all left hemisphere
%       regions. Usually generated by region2gii. Can be a dlabel.nii. If a
%       dlabel is used, set the RightHemiSphereRegionsGifti to [].
%   RightHemiSphereRegionsGifti = Gifti that contains a all right hemisphere
%       regions. Usually generated by region2gii.
%   Format = Expanded format generated by DVAR/DDAT that denotes frames
%       that should and should not be included in the calculation of seed
%       correlations.
%
%   -= OPTIONAL =-
%
%   LeftHemiSphereAuxMask = Mask to apply to left hemishpere regions.
%       Verticies defined in the mask are ignored in the calculation of seed
%       correlations.
%   RightHemiSphereAuxMask = Mask to apply to right hemishpere regions.
%       Verticies defined in the mask are ignored in the calculation of seed
%       correlations.
%   CalculateSurfaceMaps = true/false. Generate gifti ROI to all vertices 
%       surfaces for the left and right hemispheres.
%   VertexCountThreshold = Minimum number of vertices that a region must
%       have in order to have a seed correlation computed.
%   MakePCONN = true/false if you want to make a parcellated connectome
%   MinFrames = numeric. if frames < MinFrames, script will throw error and
%   exit.
%   LeftSurfaceShape =  Shape file to use for the left hemisphere. Usually
%   in the atlas/fsaverage_10k folder of the subject you are generating the
%   seed correlations for.
%       <SubjectID>.L.atlasroi.10k_fs_LR.shape.gii
%   RightSurfaceShape = Shape file to use for the right hemisphere. Should
%   be in the same location as the LeftSurfaceShape. 
%       <SubjectID>.R.atlasroi.10k_fs_LR.shape.gii
%
%TODO: Add ability to use loose gifti region files, much like volume seed
%   corr wants you to use loose volume roi regions

    %detect where wb_command is located
    %[Status, wb_command_path] = system('which wb_command','-echo');
%    assert(~Status);
    
    if(~exist('Format'))
        error('A Format was not specified for frames to include in the correlation. If no frames are to be excluded, use an empty set ( ie. [] )');
    end
    
    if(~exist('MakePCONN'))
        MakePCONN = false;
    end
    
    if(~exist('MinFrames'))
        MinFrames = 0;
    end   
    
    if(~exist('CalculateSurfaceMaps'))
        CalculateSurfaceMaps = false;
    end
    
    if(~exist('VertexCountThreshold'))
        VertexCountThreshold = -1
    end
	
    % Load the Cifti surface BOLD timecourse so we have it and some base
    % parameters
    if(exist(FunctionalSurfaceTimeSeries))
    	%cii = ciftiopen([FunctionalSurfaceTimeSeries], wb_command_path);
        raw_cii = ft_read_cifti_mod(FunctionalSurfaceTimeSeries);
    else
        error(['Functional timeseries does not exist! ' FunctionalSurfaceTimeSeries]);
    end
    
    %extract the timeseries
    if strcmp(raw_cii.dimord,'pos_time') %JSS - take pos x time or time x pos
        cii = raw_cii.data'; 
    else
        cii = raw_cii.data; 
    end
    
    %extract the vertex assignment
    brainstructure = raw_cii.brainstructure(raw_cii.brainstructure > 0);
    
    %find any voxel/vertex that equals 0 and set it to NaN
    cii = cii';
    cii(:, max(cii) == 0 & min(cii) == 0) = NaN;
    cii = cii';
    
    ROI_Labels = [];
    
    %% See if the format for this subject is binary or a string
	if(ischar(Format))
        if(~exist(Format,'file'))
            %it is a string, so binarize it
            Binary_Format = uint8(zeros(size(Format)));
            Binary_Format(Format == '+') = 1;
        elseif(ischar(Format) && exist(Format,'file'))
            %it is a format file, read it and determine what we are dealing
            %with
            disp('');
            disp(['Reading format from ' Format]);
            [result ReadFormat] = system(['cat ' Format],'-echo');
            ReadFormat = ReadFormat(~isspace(ReadFormat));
            disp('');
            if(ReadFormat(40) == '1' || ReadFormat(40) == '0') % JSS
                %format is binary, convert it to an int vector
                disp('Format appears to be a binary/fidl format file.');
                % JSS %Binary_Format = uint8(zeros(size(ReadFormat)));
                % JSS %Binary_Format(ReadFormat == '1') = 1;
                Binary_Format = importdata(Format);%% JSS
            else
                disp('Format appears to be an avi format file.');
                [result ReadFormat] = system(['format2lst -e "' ReadFormat '"' ], '-echo'); 
                fprintf('\n')
                
                Binary_Format = uint8(zeros(size(ReadFormat)));
                Binary_Format(ReadFormat == '+') = 1;
            end
        else
            error('Unknown format type.');
        end
    elseif(~ischar(Format))
        %it is binary, so just extract it
        Binary_Format = Format;
    elseif(isempty(Format) || length(Format) == 0)
        disp('No format specified, using all frames.');
        Binary_Format = ones(length(cii(1,:)));
    end
    
	fprintf('\nNumber of used frames = %d/%d\n',sum(Binary_Format),length(Binary_Format));
    if(sum(Binary_Format) <= MinFrames)
        error('Not Enough Frames.\n');
    end   
    
    
    %determine the surface space
    SurfaceVertices = length(find(brainstructure == 1)) + length(find(brainstructure == 1));
    if(SurfaceVertices < 20000)
        SurfaceSpace = '10k'
    elseif(SurfaceVertices > 20000 && SurfaceVertices < 65000)
        SurfaceSpace = '32k'
    else
        SurfaceSpace = '164k'
    end
    
    LeftSurfaceSeedCorrMaps = [];
    RightSurfaceSeedCorrMaps = [];
    
    %% read in the surface shapes and masks

    %make sure the format is for as many frames as we have in the
    %timecourse
    if(length(cii(:,1)) ~= length(Binary_Format))
        disp(['BOLD Frames in timecourse: ' num2str(length(cii(:,1))) ' Number of Frames encoded by format: ' num2str(length(Binary_Format))]);
        error('Format encodes for a different number of frames than are present in the BOLD timecourse.');
    end
    
    %% read in each hemisphere region gifti file and cast the values as uint16 to
    %save memory as each vertex will have a whole number. This will give us
    %2^16 possible region labels
    switch(GetExtension(LeftHemiSphereRegionsGifti))
        case 'gii'
            ROI_LeftHemiSphere = gifti(LeftHemiSphereRegionsGifti);

            try 
                ROI_LeftHemiSphere_Names = ROI_LeftHemiSphere.labels.name;
            catch
                ROI_LeftHemiSphere_Names = [];
            end

            ROI_LeftHemiSphere = cast(ROI_LeftHemiSphere.cdata,'uint16');

            ROI_RightHemiSphere = gifti(RightHemiSphereRegionsGifti);

            try 
                ROI_RightHemiSphere_Names = ROI_RightHemiSphere.labels.name;
            catch
                ROI_RightHemiSphere_Names = [];
            end

            ROI_RightHemiSphere = cast(ROI_RightHemiSphere.cdata,'uint16');
            
            %go through the gifti roi's and make them "cifti's"
            Cifti_ROI = [ROI_LeftHemiSphere;ROI_RightHemiSphere];
            
            %remove the undefined vertices    
            if(strcmp(GetExtension(LeftHemiSphereRegionsGifti),'gii'))
                Trimmed_Cifti_ROI = Cifti_ROI(raw_cii.brainstructure(1:length(raw_cii.brainstructure)) ~= -1 & raw_cii.brainstructure(1:length(raw_cii.brainstructure)) < 3);
            else
                Trimmed_Cifti_ROI = Cifti_ROI(raw_cii.brainstructure(1:length(raw_cii.brainstructure)) ~= -1);
            end

            Cifti_ROI = Trimmed_Cifti_ROI;

            clear Trimmed_Cifti_ROI;
    
        case 'nii'
            Cifti_ROI_data = ft_read_cifti_mod(LeftHemiSphereRegionsGifti);
            Cifti_ROI = Cifti_ROI_data.data;
        otherwise
            error('Unknown ROI file type');
    end
    
    %Initialize the correlation matrix stack
	RegionList = unique(Cifti_ROI(Cifti_ROI > 0));
     
    Read_ROI = RegionList;
    
    %count up how many vertices we started with in each region.
    SeedVertexCountInitial = [];
    
    for i = 1:length(RegionList)
        SeedVertexCountInitial = horzcat(SeedVertexCountInitial, length(find(Cifti_ROI == RegionList(i))));
    end
    
    SeedCorrMatrix = NaN(length(RegionList), length(RegionList));
         
   
    
    %put together the auxillary masks if one or both are specified
    if(exist('LeftHemiSphereAuxMask') && exist('RightHemiSphereAuxMask'))
         AuxMask = ones(length(raw_cii.brainstructure),1);
        disp('Reading Auxillary Mask...'); 
        
        %see if there is a left hemisphere aux mask and mask by the
        %hemispehere mask
        if(~isempty(LeftHemiSphereAuxMask))
            
            disp(['Reading: ' LeftHemiSphereAuxMask]);
            OriginalLeftHemiSphereAuxMaskVertices = gifti(LeftHemiSphereAuxMask);
            %extract the cdata, binarize, and compliment
            LeftHemiSphereAuxMaskVertices_Compliment = (logical(OriginalLeftHemiSphereAuxMaskVertices.cdata) * -1) + 1;
            AuxMask(1:length(LeftHemiSphereAuxMaskVertices_Compliment)) = LeftHemiSphereAuxMaskVertices_Compliment;
        end
        
        %see if there is a right hemisphere aux mask and mask by the
        %hemisphere mask
        if(~isempty(RightHemiSphereAuxMask))
            
            RH_Start = find(raw_cii.brainstructure == 2);
            RH_Start = RH_Start(1);
            
            disp(['Reading: ' RightHemiSphereAuxMask]);
            OriginalRightHemiSphereAuxMaskVertices = gifti(RightHemiSphereAuxMask);
            
            %extract the cdata, binarize, and compliment
            RightHemiSphereAuxMaskVertices_Compliment = (logical(OriginalRightHemiSphereAuxMaskVertices.cdata) * -1) +1;
            AuxMask(RH_Start:(RH_Start+length(RightHemiSphereAuxMaskVertices_Compliment)-1)) = RightHemiSphereAuxMaskVertices_Compliment;
        end

        if(strcmp(GetExtension(LeftHemiSphereRegionsGifti),'gii'))
            AuxMask = AuxMask(raw_cii.brainstructure(1:length(raw_cii.brainstructure)) ~= -1 & raw_cii.brainstructure(1:length(raw_cii.brainstructure)) < 3);
        else
            AuxMask = AuxMask(raw_cii.brainstructure(1:length(AuxMask)) ~= -1);
        end
        
        %mask
        Cifti_ROI = cast(Cifti_ROI, 'uint16') .* cast(AuxMask(1:length(Cifti_ROI)),'uint16');
    end
   
    %row = time
    %column = vertex
    %extract the cortical datapoints
	TC = single(cii(logical(Binary_Format),:));

    Unfiltered_TC = single(cii);
    
    if(length(TC(1,:)) < length(Cifti_ROI))
        disp('More ROI vertices/voxels, assuming dtseries does not have subcortical voxels.');
        Cifti_ROI = Cifti_ROI(1:length(TC(1,:)));
    elseif(length(TC(1,:)) > length(Cifti_ROI))
        disp('More vertices/voxels in dtseries, assuming ROIs do not include subcortical.');
        TC = TC(:,1:length(Cifti_ROI));
    end
    
    clear cii raw_cii;
    disp(['Creating Correlation matrix']);    
    
	% Make ROI Correlation Matrix
	ROITC = [];
    ROI_UnfilteredTC = [];
    
    SeedVertexCount = [];  
    
	%calculate the mean timecourse for each region
	for i = 1:length(RegionList)
        %grab the vertices for this region. Could be more efficient than
        %what his here
        Vertices = find(Cifti_ROI(:,1) == RegionList(i));
        
        TimeCourses = [];
        UnfilteredTimeCourse = [];
        
        for j = 1:length(Vertices)
            TimeCourses = horzcat(TimeCourses, TC(:,Vertices(j)));
            UnfilteredTimeCourse = horzcat(UnfilteredTimeCourse, Unfiltered_TC(:,Vertices(j)));
        end
        
        if(~isempty(TimeCourses))
            NumberOfVerticies = length(TimeCourses(1,:));
        else
            NumberOfVerticies = 0;
        end
        
        if(NumberOfVerticies < VertexCountThreshold || NumberOfVerticies == 0)
            TimeCourses = nan(length(TC(:,1)),1);
            
            ROITC = horzcat(ROITC, TimeCourses);
            ROI_UnfilteredTC = horzcat(ROI_UnfilteredTC, nan(length(Binary_Format),1));
        elseif(length(TimeCourses(1,:)) == 1)
            ROITC = horzcat(ROITC, TimeCourses);
            ROI_UnfilteredTC = horzcat(ROI_UnfilteredTC, UnfilteredTimeCourse);
            NumberOfVerticies = 1;
        else
            ROITC = horzcat(ROITC, mean(TimeCourses')');
            ROI_UnfilteredTC = horzcat(ROI_UnfilteredTC, mean(UnfilteredTimeCourse')');
            NumberOfVerticies = length(TimeCourses(1,:));
        end
        
        SeedVertexCount = horzcat(SeedVertexCount, NumberOfVerticies);
        
        if(CalculateSurfaceMaps)
            if(~isempty(ROI_RightHemiSphere_Names))
                GiftiOutFile = ROI_LeftHemiSphere_Names{i+1};
            else
                GiftiOutFile = ['region_' num2str(i)];
            end
            
            disp(sprintf('Generating Surface Correlation map for region %s.', GiftiOutFile));
            %compute the correlation of the region to every other vertex
            SurfaceMap = [];
            for j = 1:length(TC(1,:))
                correl = corrcoef(TC(:,j), ROITC(:,i)); 

                SurfaceMap(j,1) = correl(1,2);
            end
            
            %write the correlation surface to a right and left hemisphere
            %gifti file. Since gifti has all vertices, we must go through
            %and assign the defined vertices a correlation value;
            LeftHemisphere_SurfaceMap = CiftiToGiftiAtlas( SurfaceMap(1:length(find(LeftHemisphere_Masked_Verticies)),1), LeftHemisphere_Masked_Verticies);
            
            RightHemisphere_SurfaceMap = CiftiToGiftiAtlas( SurfaceMap(length(find(LeftHemisphere_Masked_Verticies))+1 : length(SurfaceMap)), RightHemisphere_Masked_Verticies );
            
            save_gii([GiftiOutFile '_surface_map'], SurfaceSpace, LeftHemisphere_SurfaceMap, RightHemisphere_SurfaceMap);
        end
        
    end
    
    if(MakePCONN && ~isempty(ROI_RightHemiSphere_Names))
        
        disp('Making PCONN...');
        
        [~,ParcelName,~]=fileparts(LeftHemiSphereRegionsGifti);
        [~,ParcelName,~]=fileparts(ParcelName);
        [~,ParcelName,~]=fileparts(ParcelName);
        [~,Parcel_TCName,~]=fileparts(FunctionalSurfaceTimeSeries);
        [~,Parcel_TCName,~]=fileparts(Parcel_TCName);
        [~,Parcel_TCName,~]=fileparts(Parcel_TCName);
        
        command = [getenv('CARET7DIR') '/wb_command -cifti-create-label ' ParcelName '.dlabel.nii -left-label ' LeftHemiSphereRegionsGifti ' -right-label ' RightHemiSphereRegionsGifti]
        assert(~system(command,'-echo'));
        
        command = [getenv('CARET7DIR') '/wb_command -cifti-parcellate ' FunctionalSurfaceTimeSeries ' ' ParcelName '.dlabel.nii COLUMN ' Parcel_TCName '.' ParcelName '.ptseries.nii']
        assert(~system(command,'-echo'));
        
        command = [getenv('CARET7DIR') '/wb_command -cifti-correlation ' Parcel_TCName '.' ParcelName '.ptseries.nii ' Parcel_TCName '.' ParcelName '.pconn.nii'];
        assert(~system(command,'-echo'));
    end
    
	SeedCorrMatrix = corrcoef(ROITC);
    Seed_TC_Var = var(ROITC);
    SeedVertexCountIgnored = SeedVertexCountInitial - SeedVertexCount;
end